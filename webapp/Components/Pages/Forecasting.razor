@page "/forecast"
@inject HttpClient Http
@using System.Text.Json

<PageTitle>Demand Forecasting</PageTitle>

<div class="page-header">
    <h1>ðŸ“ˆ Demand Forecasting</h1>
    <p>Predict future inventory levels using Prophet and LSTM models</p>
</div>

<div class="how-it-works">
    <h3>ðŸ“– Forecasting Engine</h3>
    <p>Predicts future warehouse inventory levels to optimize stock management:</p>
    <ul>
        <li><strong>Prophet</strong>: Facebook's additive model ideal for daily/weekly seasonality</li>
        <li><strong>LSTM</strong>: Deep Learning model capturing complex non-linear temporal dependencies</li>
    </ul>
</div>

<div class="control-bar">
    <div class="form-group">
        <label>Forecast Horizon (Hours)</label>
        <input type="range" @bind="horizonHours" min="24" max="168" step="24" />
        <span>@horizonHours hours</span>
    </div>
    <div class="form-group">
        <label>Model</label>
        <select @bind="modelType">
            <option value="prophet">Prophet</option>
            <option value="lstm">LSTM</option>
        </select>
    </div>
    <button class="btn-primary" @onclick="GenerateForecast">Generate Forecast</button>
</div>

@if (isLoading)
{
    <div class="loading">Generating forecast...</div>
}
else if (forecastData.Count > 0)
{
    <div class="forecast-metrics">
        <div class="metric-card">
            <span class="metric-label">Model Used</span>
            <span class="metric-value">@modelType.ToUpper()</span>
        </div>
        <div class="metric-card">
            <span class="metric-label">Historical Mean</span>
            <span class="metric-value">@historicalMean.ToString("N0")</span>
        </div>
        <div class="metric-card">
            <span class="metric-label">Forecast Points</span>
            <span class="metric-value">@forecastData.Count</span>
        </div>
    </div>
    
    <div class="forecast-table">
        <h3>ðŸ“Š Forecast Data</h3>
        <table>
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Predicted Inventory</th>
                    <th>Lower Bound</th>
                    <th>Upper Bound</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var point in forecastData.Take(24))
                {
                    <tr>
                        <td>@point.Timestamp</td>
                        <td class="value">@point.PredictedValue.ToString("N0")</td>
                        <td>@point.LowerBound.ToString("N0")</td>
                        <td>@point.UpperBound.ToString("N0")</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code {
    private int horizonHours = 48;
    private string modelType = "prophet";
    private bool isLoading = false;
    private List<ForecastPoint> forecastData = new();
    private double historicalMean = 0;

    private class ForecastPoint
    {
        public string Timestamp { get; set; } = "";
        public double PredictedValue { get; set; }
        public double LowerBound { get; set; }
        public double UpperBound { get; set; }
    }

    private async Task GenerateForecast()
    {
        isLoading = true;
        forecastData.Clear();
        
        try
        {
            var request = new { horizon_hours = horizonHours, model_type = modelType };
            var response = await Http.PostAsJsonAsync("http://localhost:8000/api/forecast/predict", request);
            var result = await response.Content.ReadFromJsonAsync<JsonElement>();
            
            historicalMean = result.GetProperty("metrics").GetProperty("historical_mean").GetDouble();
            
            foreach (var point in result.GetProperty("forecast").EnumerateArray())
            {
                forecastData.Add(new ForecastPoint
                {
                    Timestamp = point.GetProperty("timestamp").GetString() ?? "",
                    PredictedValue = point.GetProperty("predicted_value").GetDouble(),
                    LowerBound = point.GetProperty("lower_bound").GetDouble(),
                    UpperBound = point.GetProperty("upper_bound").GetDouble()
                });
            }
        }
        catch
        {
            // Generate mock data
            var random = new Random(42);
            historicalMean = 150;
            var baseTime = DateTime.Now;
            
            for (int i = 0; i < horizonHours; i++)
            {
                var predicted = historicalMean + random.NextDouble() * 20 - 10;
                forecastData.Add(new ForecastPoint
                {
                    Timestamp = baseTime.AddHours(i).ToString("yyyy-MM-dd HH:mm"),
                    PredictedValue = predicted,
                    LowerBound = predicted - 15,
                    UpperBound = predicted + 15
                });
            }
        }
        
        isLoading = false;
    }
}
